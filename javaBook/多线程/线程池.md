# 线程池

## 1.为什么使用线程池？

线程是稀缺资源，它的创建与销毁是一个相对偏重且耗资源的一个过程，而java线程依赖于内核进程，创建线程需要进行操作系统状态切换，为避免资源过度消耗需要设法    重用线程执行多个任务   。线程池就是一个线程缓存，负责对线程进行统一分配、调优与监控。

创建线程和销毁线程的花销是比较大的，这些时间有可能比处理业务的时间还要长。这样频繁的创建线程和销毁线程，再加上业务工作线程，消耗系统资源的时间，可能导致系统资源不足。（我们可以把创建和销毁的线程的过程去掉）

多线程的异步执行方式，虽然能够最大限度发挥多核计算机的计算能力，但是如果不加控制，反而会对系统造成负担。线程本身也要占用内存空间，大量的线程会占用内存资源并且可能会导致Out of Memory。即便没有这样的情况，大量的线程回收也会给GC带来很大的压力。

为了避免重复的创建线程，线程池的出现可以让线程进行复用。通俗点讲，当有工作来，就会向线程池拿一个线程，当工作完成后，并不是直接关闭线程，而是将这个线程归还给线程池供其他任务使用。

## 2.什么时候使用线程池？

1. 单个任务处理时间比较短
2. 需要处理的任务数量很大

## 3.线程池的优势是什么

- 重用存在的线程，减少线程创建，消亡的开销，提高性能

- 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行

- 提高线程的可管理型，可统一分配，调优和监控

  ## 4.线程池调度原理



![image-20200909111154111](\线程池.assets\image-20200909111154111.png)

线程的基本原理：

```java
ThreadPoolExecutor pool = new ThreadPoolExecutor(2,3,60,
        TimeUnit.SECONDS,new ArrayBlockingQueue<>(5), Executors.defaultThreadFactory());
```

核心线程执行任务，若核心线程满负荷工作后，任务放入阻塞队列排队。

ArrayBlockingQueue虽然是队列，但是底层数据结构是数组。

若阻塞队列放满，则会创建非核心线程（maximunPoolSize-corePool）

核心线程和非核心线程同时竞争CPU

PS:阻塞队列里的任务还是由核心线程执行



阻塞队列：

FIFO 先进先出

1.在任意时刻，不管并发有多高，永远只有一个线程能够进入队列的入队或者出队操作！是线程安全的队列

有界 || 无界

5

队列满，只能进行出队操作，所有队列的操作必须等待，也就是被阻塞

0

队列空，只能进行入队操作，所有队列的操作必须等待，也就是被阻塞



## 5.线程池的五种状态

![image-20200909144843511](线程池.assets\image-20200909144843511.png)

![image-20200909144947761](线程池.assets\image-20200909144947761.png)

pool.shutdown():

如果队列有任务，告诉线程池不在接收新的任务，但队列里的任务，核心线程会执行完

pool.shutdownNow():

![image-20200909145926620](线程池.assets\image-20200909145926620.png)

# 线程基础

## 心得感悟

多线程存在的目的是提高CPU利用率，加快接口响应速度

当用户请求后台时，每个请求就是一个线程，当进入方法时，每个线程相当于一个主线程，如果要进行请求比较长的数据，那么可以用线程池去创建线程进行多线程的操作，保证方法响应速度提升。

但是多线程会存在线程安全，数据一致性的问题，所以必要的时候使用线程安全的集合或者加锁synchrnized或者AQS（抽象队列同步器），比如reentrantLock 自旋+park()+队列

在方法里要使用多线程一定要new Thread()，然后注意线程安全，尽量用线程安全的集合 concurrentHashMap等

## 1.线程生命周期

![image-20200923111441043](线程池.assets\image-20200923111441043.png)

#### 第一点、java线程新生态的生成

![image-20200923111504128](线程池.assets\image-20200923111504128.png)

![image-20200923111518562](线程池.assets\image-20200923111518562.png)

#### 

#### 第二点 java由新生态转换为就绪态

如果只调用run方法，还是在主线程执行run方法，不会开启新的线程，线程不会进入到就绪状态，所以start方法才是开启线程的方法，

run方法中存入的只是任务内容。代码如下：

![image-20200923111621996](线程池.assets\image-20200923111621996.png)