# 线程池

## 1.为什么使用线程池？

线程是稀缺资源，它的创建与销毁是一个相对偏重且耗资源的一个过程，而java线程依赖于内核进程，创建线程需要进行操作系统状态切换，为避免资源过度消耗需要设法重用线程执行多个任务。线程池就是一个线程缓存，负责对线程进行统一分配、调优与监控。

创建线程和销毁线程的花销是比较大的，这些时间有可能比处理业务的时间还要长。这样频繁的创建线程和销毁线程，再加上业务工作线程，消耗系统资源的时间，可能导致系统资源不足。（我们可以把创建和销毁的线程的过程去掉）

## 2.什么时候使用线程池？

1. 单个任务处理时间比较短
2. 需要处理的任务数量很大

## 3.线程池的优势是什么

- 重用存在的线程，减少线程创建，消亡的开销，提高性能

- 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行

- 提高线程的可管理型，可统一分配，调优和监控

  ## 4.线程池调度原理



![image-20200909111154111](\线程池.assets\image-20200909111154111.png)

线程的基本原理：

```java
ThreadPoolExecutor pool = new ThreadPoolExecutor(2,3,60,
        TimeUnit.SECONDS,new ArrayBlockingQueue<>(5), Executors.defaultThreadFactory());
```

核心线程执行任务，若核心线程满负荷工作后，任务放入阻塞队列排队。

ArrayBlockingQueue虽然是队列，但是底层数据结构是数组。

若阻塞队列放满，则会创建非核心线程（maximunPoolSize-corePool）

核心线程和非核心线程同时竞争CPU

PS:阻塞队列里的任务还是由核心线程执行



阻塞队列：

FIFO 先进先出

1.在任意时刻，不管并发有多高，永远只有一个线程能够进入队列的入队或者出队操作！是线程安全的队列

有界 || 无界

5

队列满，只能进行出队操作，所有队列的操作必须等待，也就是被阻塞

0

队列空，只能进行入队操作，所有队列的操作必须等待，也就是被阻塞



## 5.线程池的五种状态

![image-20200909144843511](线程池.assets\image-20200909144843511.png)

![image-20200909144947761](线程池.assets\image-20200909144947761.png)

pool.shutdown():

如果队列有任务，告诉线程池不在接收新的任务，但队列里的任务，核心线程会执行完

pool.shutdownNow():

![image-20200909145926620](线程池.assets\image-20200909145926620.png)